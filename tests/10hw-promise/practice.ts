//1. Function Declaration
console.log(sum(2, 3))

function sum(a: number, b: number) {
    return a + b
}
console.log(sum(1, 3))
//✅ Зберігається в змінній
//✅ Не піднімається (не можна викликати до оголошення)
//✅ Використовується для функцій в якості аргументів

//2. Function Expression
//console.log(multiply(3, 4))
const multiply = function (a: number, b: number) {
    return a * b
}

console.log(multiply(3, 4))

// ✅ Зберігається в змінній
// ✅ Не піднімається (не можна викликати до оголошення)
// ✅ Використовується для функцій в якості аргументів

//3. Arrow Function (=>)
const add = (a: number, b: number) => a + b

//✅ Коротший запис функції
//✅ this успадковується від зовнішньої області
//✅ Автоматичне повернення (якщо один вираз)

//Замикання (Сlosures)
// Замикання (Closure) — це функція, яка "запам'ятовує" середовище, в якому вона була створена, навіть після того, як це середовище більше не існує. Замикання дає можливість функції доступати до змінних, які оголошені поза її межами, навіть якщо ці змінні знаходяться поза функцією після її виконання.

function outer() {
    let counter = 0;  // Змінна, доступна тільки всередині outer

    function inner() {  // Функція замикання
        counter++;  // Має доступ до змінної counter з outer
        console.log(counter);
    }

    return inner;  // Повертаємо inner, що зберігає доступ до counter
}

const increment = outer();  // Викликаємо outer і отримуємо inner
increment();
increment();
increment();

// Інкапсуляція даних
// Замикання дозволяє інкапсулювати дані, тобто обмежити доступ до змінних тільки через певні функції. Це корисно для створення приватних змінних та методів.
function createCounter() {
    let count = 0;  // Приватна змінна, доступна тільки через замикання

    return {
        increment: function () {
            count++;
            console.log(count);
        },
        decrement: function () {
            count--;
            console.log(count);
        },
        getCount: function () {
            return count;
        }
    };
}

const counter = createCounter();
counter.increment();  // 1
counter.increment();  // 2
counter.decrement();  // 1
console.log(counter.getCount());  // 1

// Функції з пам'яттю
// Замикання дозволяють створювати функції, які зберігають "стан" між викликами.

function makeAdder(x: number) {
    return function (y: number) {
        return x + y;
    }

}
const addFive = makeAdder(5);
console.log(addFive(10));
console.log(addFive(15))


// Рекурсія в програмуванні — це техніка, коли функція викликає сама себе для вирішення підзадачі, поки не досягне базового випадку (умови зупинки), після чого виконується повернення результату. Це особливо корисно для вирішення задач, які мають подібну структуру до задачі, яку потрібно вирішити, наприклад, перебір дерев або обчислення факторіалу.

// Ось основні компоненти рекурсії:

// Базовий випадок: Це умова, при якій функція більше не викликає сама себе і повертає результат. Це необхідно, щоб уникнути нескінченного виклику функції.

// Рекурсивний виклик: Функція викликає сама себе, часто з іншими параметрами, щоб наблизитись до базового випадку.

// Приклад: Обчислення факторіалу
// Факторіал числа n — це добуток всіх цілих чисел від 1 до n. Це можна обчислити рекурсивно:

function factorial(n: number): number {
    if (n === 0 || n === 1) {
        return 1; //Базовий випадок
    }
    return n * factorial(n - 1); // Рекурсивний виклик
}

console.log(factorial(5));